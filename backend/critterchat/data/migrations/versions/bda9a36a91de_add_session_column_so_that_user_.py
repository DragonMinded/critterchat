"""Add session column so that user settings can be per-session instead of per-account.

Revision ID: bda9a36a91de
Revises: 1f5c51185c0b
Create Date: 2025-08-03 17:25:50.552951

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.sql import text


# revision identifiers, used by Alembic.
revision = 'bda9a36a91de'
down_revision = '1f5c51185c0b'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('settings', sa.Column('session', sa.String(length=32), nullable=False))
    op.drop_index(op.f('ix_settings_user_id'), table_name='settings')
    op.create_index(op.f('ix_settings_user_id'), 'settings', ['user_id'], unique=False)
    # ### end Alembic commands ###

    # Kill any settings since we can't easily look up the session for them.
    conn = op.get_bind()
    conn.execute(text("UPDATE settings, session SET settings.session = session.session WHERE session.id = settings.user_id"))  # type: ignore

    # Now, migrate settings over for each session.
    cursor = conn.execute(text("SELECT id FROM user"))  # type: ignore
    seen = set()
    for result in cursor.mappings():
        cursor2 = conn.execute(text("SELECT last_room, info FROM settings WHERE user_id = :userid LIMIT 1"), {'userid': result['id']})  # type: ignore
        if cursor2.rowcount == 1:
            result2 = cursor2.mappings().fetchone()

            cursor3 = conn.execute(text("SELECT session FROM session WHERE id = :userid"), {'userid': result['id']})  # type: ignore
            for result3 in cursor3.mappings():
                if result3['session'] in seen:
                    continue
                seen.add(result3['session'])

                conn.execute(text(  # type: ignore
                """
                    INSERT INTO settings
                        (`session`, `user_id`, `last_room`, `info`)
                    VALUES
                        (:session, :userid, :lastroom, :info)
                    ON DUPLICATE KEY UPDATE user_id = user_id
                """), {'session': result3['session'], 'userid': result['id'], 'lastroom': result2['last_room'], 'info': result2['info']})

    # Now, kill any duplicate settings that snuck in.
    cursor = conn.execute(text("SELECT session FROM settings"))  # type: ignore
    for result in cursor.mappings():
        cursor2 = conn.execute(text("SELECT count(session) AS c FROM settings WHERE session = :session"), {'session': result['session']})  # type: ignore
        if cursor2.rowcount == 1:
            result2 = cursor2.mappings().fetchone()
            count = int(result2['c'])
            if count > 1:
                conn.execute(text("DELETE FROM settings WHERE session = :session LIMIT :count"), {'session': result['session'], 'count': count - 1})  # type: ignore

    # Now, delete any old settings.
    conn.execute(text("DELETE FROM settings WHERE session = ''"))  # type: ignore
    op.create_index(op.f('ix_settings_session'), 'settings', ['session'], unique=True)


def downgrade() -> None:
    # Get rid of multiple settings for unique constraint.
    conn = op.get_bind()
    cursor = conn.execute(text("SELECT id FROM user"))  # type: ignore
    for result in cursor.mappings():
        cursor2 = conn.execute(text("SELECT session FROM settings WHERE user_id = :userid"), {'userid': result['id']})  # type: ignore
        if cursor2.rowcount > 1:
            for i, result2 in enumerate(cursor2.mappings()):
                if i == 0:
                    continue

                conn.execute(text("DELETE FROM settings WHERE session = :session"), {'session': result2['session']})  # type: ignore

    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_settings_session'), table_name='settings')
    op.drop_index(op.f('ix_settings_user_id'), table_name='settings')
    op.create_index(op.f('ix_settings_user_id'), 'settings', ['user_id'], unique=True)
    op.drop_column('settings', 'session')
    # ### end Alembic commands ###
